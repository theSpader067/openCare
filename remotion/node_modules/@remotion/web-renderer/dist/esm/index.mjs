// src/render-still-on-web.tsx
import { flushSync } from "react-dom";
import ReactDOM from "react-dom/client";
import { Internals } from "remotion";

// src/compose.ts
var svgToImageBitmap = (svg) => {
  const computedStyle = getComputedStyle(svg);
  const { transform: originalTransform } = computedStyle;
  svg.style.transform = "none";
  const svgDimensions = svg.getBoundingClientRect();
  svg.style.transform = originalTransform;
  if (svgDimensions.width === 0 || svgDimensions.height === 0) {
    return Promise.resolve(null);
  }
  const svgData = new XMLSerializer().serializeToString(svg);
  return new Promise((resolve, reject) => {
    const image = new Image(svgDimensions.width, svgDimensions.height);
    const url = "data:image/svg+xml;base64," + window.btoa(svgData);
    image.onload = function() {
      resolve({
        image,
        width: svgDimensions.width,
        height: svgDimensions.height,
        left: svgDimensions.left,
        top: svgDimensions.top
      });
    };
    image.onerror = () => {
      reject(new Error("Failed to convert SVG to image"));
    };
    image.src = url;
  });
};
var compose = async ({
  composables,
  width,
  height
}) => {
  const canvas = new OffscreenCanvas(width, height);
  const context = canvas.getContext("2d");
  if (!context) {
    throw new Error("Could not get context");
  }
  for (const composable of composables) {
    if (composable.type === "canvas") {
      const boundingClientRect = composable.element.getBoundingClientRect();
      context.drawImage(composable.element, boundingClientRect.left, boundingClientRect.top);
    } else if (composable.type === "svg") {
      const imageBitmap = await svgToImageBitmap(composable.element);
      if (imageBitmap) {
        context.drawImage(imageBitmap.image, imageBitmap.left, imageBitmap.top);
      }
    }
  }
  return canvas;
};

// src/find-canvas-elements.ts
var findCanvasElements = (element) => {
  const canvasElements = element.querySelectorAll("canvas");
  const composables = [];
  Array.from(canvasElements).forEach((canvasElement) => {
    const canvas = canvasElement;
    composables.push({
      type: "canvas",
      element: canvas
    });
  });
  return composables;
};

// src/find-svg-elements.ts
var findSvgElements = (element) => {
  const svgElements = element.querySelectorAll("svg");
  const composables = [];
  Array.from(svgElements).forEach((svgElement) => {
    const svg = svgElement;
    composables.push({
      type: "svg",
      element: svg
    });
  });
  return composables;
};

// src/with-resolvers.ts
var withResolvers = function() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};

// src/wait-for-ready.ts
var waitForReady = (timeoutInMilliseconds, scope) => {
  if (scope.remotion_renderReady === true) {
    return Promise.resolve();
  }
  const start = Date.now();
  const { promise, resolve, reject } = withResolvers();
  const interval = setInterval(() => {
    if (scope.remotion_renderReady === true) {
      requestAnimationFrame(() => {
        resolve();
      });
      clearInterval(interval);
      return;
    }
    if (scope.remotion_cancelledError !== undefined) {
      reject(scope.remotion_cancelledError);
      clearInterval(interval);
      return;
    }
    if (Date.now() - start > timeoutInMilliseconds + 3000) {
      reject(new Error(Object.values(scope.remotion_delayRenderTimeouts).map((d) => d.label).join(", ")));
      clearInterval(interval);
    }
  }, 50);
  return promise;
};

// src/render-still-on-web.tsx
import { jsx } from "react/jsx-runtime";
var COMP_ID = "markup";
async function internalRenderStillOnWeb({
  Component,
  width,
  height,
  fps,
  durationInFrames,
  frame,
  delayRenderTimeoutInMilliseconds,
  logLevel,
  inputProps
}) {
  const div = document.createElement("div");
  div.style.display = "flex";
  div.style.backgroundColor = "transparent";
  div.style.position = "fixed";
  div.style.width = `${width}px`;
  div.style.height = `${height}px`;
  div.style.zIndex = "-9999";
  document.body.appendChild(div);
  if (!ReactDOM.createRoot) {
    throw new Error("@remotion/web-renderer requires React 18 or higher");
  }
  const { promise, resolve, reject } = withResolvers();
  const root = ReactDOM.createRoot(div, {
    onUncaughtError: (err) => {
      reject(err);
    }
  });
  const delayRenderScope = {
    remotion_renderReady: true,
    remotion_delayRenderTimeouts: {},
    remotion_puppeteerTimeout: delayRenderTimeoutInMilliseconds,
    remotion_attempt: 0
  };
  flushSync(() => {
    root.render(/* @__PURE__ */ jsx(Internals.RemotionEnvironmentContext, {
      value: {
        isStudio: false,
        isRendering: true,
        isPlayer: false,
        isReadOnlyStudio: false,
        isClientSideRendering: true
      },
      children: /* @__PURE__ */ jsx(Internals.DelayRenderContextType.Provider, {
        value: delayRenderScope,
        children: /* @__PURE__ */ jsx(Internals.CompositionManager.Provider, {
          value: {
            compositions: [
              {
                id: COMP_ID,
                component: Component,
                nonce: 0,
                defaultProps: undefined,
                folderName: null,
                parentFolderName: null,
                schema: null,
                calculateMetadata: null,
                durationInFrames,
                fps,
                height,
                width
              }
            ],
            canvasContent: {
              type: "composition",
              compositionId: COMP_ID
            },
            currentCompositionMetadata: {
              props: inputProps,
              durationInFrames,
              fps,
              height,
              width,
              defaultCodec: null,
              defaultOutName: null,
              defaultVideoImageFormat: null,
              defaultPixelFormat: null,
              defaultProResProfile: null
            },
            folders: []
          },
          children: /* @__PURE__ */ jsx(Internals.RemotionRoot, {
            audioEnabled: false,
            videoEnabled: true,
            logLevel,
            numberOfAudioTags: 0,
            audioLatencyHint: "interactive",
            frameState: {
              [COMP_ID]: frame
            },
            children: /* @__PURE__ */ jsx(Internals.CanUseRemotionHooks, {
              value: true,
              children: /* @__PURE__ */ jsx(Component, {
                ...inputProps
              })
            })
          })
        })
      })
    }));
  });
  resolve();
  await promise;
  await waitForReady(delayRenderTimeoutInMilliseconds, delayRenderScope);
  const canvasElements = findCanvasElements(div);
  const svgElements = findSvgElements(div);
  const composed = await compose({
    composables: [...canvasElements, ...svgElements],
    width,
    height
  });
  const imageData = await composed.convertToBlob({
    type: "image/png"
  });
  root.unmount();
  div.remove();
  return imageData;
}
var renderStillOnWeb = (options) => {
  return internalRenderStillOnWeb({
    ...options,
    delayRenderTimeoutInMilliseconds: options.delayRenderTimeoutInMilliseconds ?? 30000,
    logLevel: options.logLevel ?? "info"
  });
};
export {
  renderStillOnWeb
};
