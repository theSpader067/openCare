import { jsx as _jsx } from "react/jsx-runtime";
import { flushSync } from 'react-dom';
import ReactDOM from 'react-dom/client';
import { Internals } from 'remotion';
import { compose } from './compose';
import { findCanvasElements } from './find-canvas-elements';
import { findSvgElements } from './find-svg-elements';
import { waitForReady } from './wait-for-ready';
import { withResolvers } from './with-resolvers';
const COMP_ID = 'markup';
async function internalRenderStillOnWeb({ Component, width, height, fps, durationInFrames, frame, delayRenderTimeoutInMilliseconds, logLevel, inputProps, }) {
    const div = document.createElement('div');
    // Match same behavior as renderEntry.tsx
    div.style.display = 'flex';
    div.style.backgroundColor = 'transparent';
    div.style.position = 'fixed';
    div.style.width = `${width}px`;
    div.style.height = `${height}px`;
    div.style.zIndex = '-9999';
    document.body.appendChild(div);
    if (!ReactDOM.createRoot) {
        throw new Error('@remotion/web-renderer requires React 18 or higher');
    }
    // TODO: Env variables
    // TODO: Input Props
    // TODO: Default props
    // TODO: getInputProps()
    // TODO: calculateMetadata()
    // TODO: getRemotionEnvironment()
    // TODO: delayRender()
    // TODO: Video config
    const { promise, resolve, reject } = withResolvers();
    // TODO: This might not work in React 18
    const root = ReactDOM.createRoot(div, {
        onUncaughtError: (err) => {
            reject(err);
        },
    });
    const delayRenderScope = {
        remotion_renderReady: true,
        remotion_delayRenderTimeouts: {},
        remotion_puppeteerTimeout: delayRenderTimeoutInMilliseconds,
        remotion_attempt: 0,
    };
    flushSync(() => {
        root.render(_jsx(Internals.RemotionEnvironmentContext, { value: {
                isStudio: false,
                isRendering: true,
                isPlayer: false,
                isReadOnlyStudio: false,
                isClientSideRendering: true,
            }, children: _jsx(Internals.DelayRenderContextType.Provider, { value: delayRenderScope, children: _jsx(Internals.CompositionManager.Provider, { value: {
                        compositions: [
                            {
                                id: COMP_ID,
                                // @ts-expect-error
                                component: Component,
                                nonce: 0,
                                // TODO: Do we need to allow to set this?
                                defaultProps: undefined,
                                folderName: null,
                                parentFolderName: null,
                                schema: null,
                                calculateMetadata: null,
                                durationInFrames,
                                fps,
                                height,
                                width,
                            },
                        ],
                        canvasContent: {
                            type: 'composition',
                            compositionId: COMP_ID,
                        },
                        currentCompositionMetadata: {
                            props: inputProps,
                            durationInFrames,
                            fps,
                            height,
                            width,
                            defaultCodec: null,
                            defaultOutName: null,
                            defaultVideoImageFormat: null,
                            defaultPixelFormat: null,
                            defaultProResProfile: null,
                        },
                        folders: [],
                    }, children: _jsx(Internals.RemotionRoot, { audioEnabled: false, videoEnabled: true, logLevel: logLevel, numberOfAudioTags: 0, audioLatencyHint: "interactive", frameState: {
                            [COMP_ID]: frame,
                        }, children: _jsx(Internals.CanUseRemotionHooks, { value: true, children: _jsx(Component, { ...inputProps }) }) }) }) }) }));
    });
    resolve();
    await promise;
    await waitForReady(delayRenderTimeoutInMilliseconds, delayRenderScope);
    const canvasElements = findCanvasElements(div);
    const svgElements = findSvgElements(div);
    const composed = await compose({
        composables: [...canvasElements, ...svgElements],
        width,
        height,
    });
    const imageData = await composed.convertToBlob({
        type: 'image/png',
    });
    root.unmount();
    div.remove();
    return imageData;
}
export const renderStillOnWeb = (options) => {
    var _a, _b;
    return internalRenderStillOnWeb({
        ...options,
        delayRenderTimeoutInMilliseconds: (_a = options.delayRenderTimeoutInMilliseconds) !== null && _a !== void 0 ? _a : 30000,
        logLevel: (_b = options.logLevel) !== null && _b !== void 0 ? _b : 'info',
    });
};
